
\chapter{The 6800x Instruction Set -{} continued}

\section{Introduction}
\label{ch4-intro}%\hyperlabel{ch4-intro}%

Following on from the previous chapter, we now start to look at the
    logical instructions in the MC6800x instruction set.

Logic is the heart of all computer systems -{} well, all digital ones
    anyway. Logic is how the central processor works. The 68000 series of
    processors are no exception and in the instruction set, there are a few
    logical operations that can be carried out. This chapter discusses those
    instructions.

\section{Tie the NOT}\mc6800x{NOT}
\label{ch4-Logic}%\hyperlabel{ch4-Logic}%

The logical \opcode{NOT} instruction is probably the simplest of all this
    family of instruction. It converts the destination address from its
    current state of ones and zeros into the exact opposite to zeros and ones.
    The format is:

\begin{lstlisting}[firstnumber=1,]
          NOT.size destination
\end{lstlisting}

Size can be byte, word or long. The instruction carries out a `ones
    compliment' of the destination address. If you remember back to the
    discussion of `Twos compliment' numbers earlier on in the series, you will
    remember that converting a positive number to negative involved flipping
    all the zeros and ones and then adding one to the result. The \opcode{NOT}
    instruction carries out the first part of flipping all the ones and zeros
    over.

If D0.W holds the value of \$0001 then after a \lstinline{NOT.W D0}, it will hold
    the value \$FFFE. All the original zeros have become ones and vice
    versa.

NOT must not be confused with the arithmetic \opcode{NEG} instruction which
    carries out a `twos compliment' negation of a value. (D0.W in the above
    example would become \$FFFF which is equivalent to \lstinline{NOT.W D0} followed by
    \lstinline{ADDQ.W \#1,D0})

NOT affects the flags in the following way:
\begin{itemize}[itemsep=0pt]

\item{}N is set if the result becomes negative -{} the most significant
        bit becomes a 1. Cleared otherwise.


\item{}Z is set if the result is zero, cleared otherwise.


\item{}V is always cleared -{} you cannot create an overflow by inverting
        the bits.


\item{}C is always cleared -{} there is no carry generated by flipping
        bits.


\item{}X is not affected.

\end{itemize}

The destination cannot be an address register nor any of the PC relative addressing modes.

\section{This OR That}\mc6800x{OR}
\label{ch4-or}%\hyperlabel{ch4-or}%

Next up in the logical family is the \opcode{OR} instruction of which there
    are a few. \opcode{OR} is quite different from \opcode{NOT} in that it needs to have two
    operands in order to be used. The format of the \opcode{OR} instruction is:

\begin{lstlisting}[firstnumber=1,]
          OR.size source_ea,Dn
\end{lstlisting}

or

\begin{lstlisting}[firstnumber=1,]
          OR.size Dn,destination_ea
\end{lstlisting}

Note that in this form of the instruction either the source or the
    destination must be a data register. The size can be byte, word or
    long.

\begin{warning}
The source\_ea cannot be an address register. 

The destination\_ea also cannot be an address register, neither can it be a data register, immediate data or a PC relative addressing mode. 
\end{warning}    

This is the `inclusive or' instruction -{} there is also an `exclusive
    or' variety which we will see later on in this article. An inclusive or
    works according to the truth table for Logical \opcode{OR} in Table~\ref{tab:TruthTableForLogicalOR}.


\begin{table}[h]
\centering
\begin{tabular}{cc|c}

Source & Destination & OR\\ \hline
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 1

\label{tab:ORTruthTable}
\end{tabular}
\caption{Truth Table for Logical OR.}
\label{tab:TruthTableForLogicalOR}
\end{table}


Simply imagine each individual bit in the source is being \opcode{OR}'d with
    the same bit in the destination. The result -{} which will be stored in the
    destination bit -{} will always be a 1 if one OR other of the two bits being
    processed is a 1. If both are zero then the result will also be
    zero.

An example

D0.W contains \$AAAA and D1.W contains \$6543 the instruction

\begin{lstlisting}[firstnumber=1,]
          OR.W D0,D1
\end{lstlisting}

Will result in D1.W being set to \$EFEB and D0 will remain unchanged.
    How does this work? In binary:

\begin{lstlisting}[firstnumber=1,frame=none,numbers=none]
D0 = $AAAA = 1010 1010 1010 1010
D1 = $6543 = 0110 0101 0100 0011
\end{lstlisting}

So using the truth table above, the result will be:

\begin{lstlisting}[firstnumber=1,frame=none,numbers=none]
D1 = $EFEB = 1110 1111 1110 1011
\end{lstlisting}

The flags affected by \opcode{OR} are exactly the same as for \opcode{NOT}
    above.
    
The OR Immediate\mc6800x{ORI} format of the \opcode{OR} instruction has the format
   :

\begin{lstlisting}[firstnumber=1,]
          ORI.size #data,destination_ea
\end{lstlisting}

and can be byte, word or long sized. It is used when the source
    value in the \opcode{OR} is immediate data as opposed to a register or memory
    address. 
    
\begin{warning}
The destination\_ea cannot be an address register, neither can it be immediate data or a PC relative addressing mode. 
\end{warning}   
    
Some, but not all, assemblers will allow you to write:

\begin{lstlisting}[firstnumber=1,]
          OR.size #data,destination
\end{lstlisting}

But the actual instruction assembled will be \opcode{ORI} instead. Again the
    flags are affected as for \opcode{NOT}.
    
\begin{note}
It has been agreed that any assembler which silently changes the assembled instruction is a bad assembler! The result \emph{should} be the same either way, and the flags will be the same also, but the actual binary coding of the assembled instruction will differ which means that a dissassembly will give a different source to that which was originally used.

Some assemblers allow you to select whether this change takes place, or not, \program{Gwass}Gwass for example.
\end{note}    

\begin{lstlisting}[firstnumber=1,]
          ORI #data,CCR 
\end{lstlisting}

This instruction is used to set the flags to a set of known values
    as supplied in the immediate data. This instruction only uses bits 0
    through 4 of the data supplied as the other bits are not used in the
    68008. As it is possible that future processors may introduce other flags,
    you are always best to make sure that bits 6 through 7 are zero when using
    this (and the following) instruction. That way, you won't cause any
    `strange effects' on a different processor.

The flags are set as:
\begin{itemize}[itemsep=0pt]

\item{}C is set if value in bit 0 of the data is a 1 otherwise
        unaffected.


\item{}V is set if value in bit 1 of the data is a 1 otherwise
        unaffected.


\item{}Z is set if value in bit 2 of the data is a 1 otherwise
        unaffected.


\item{}N is set if value in bit 3 of the data is a 1 otherwise
        unaffected.


\item{}X is set if value in bit 4 of the data is a 1 otherwise
        unaffected.

\end{itemize}

\begin{lstlisting}[firstnumber=1,]
          ORI #data,SR 
\end{lstlisting}

This is a similar instruction to the one above, and does a similar
    job except it affects the entire status register. The other difference is
    that the processor must be running in Supervisor mode for this instruction
    to be carried out. If it is not then a privilege exception will be
    generated -{} this will hang the QL (usually)

As above, the flags are set according to the data -{} bits 0 to 4. The
    rest of the status register is set as follows:
\begin{itemize}[itemsep=0pt]

\item{}T (trace) is set if value in bit 15 of the data is a 1 otherwise
        unaffected.


\item{}S (supervisor) is set if value in bit 13 of the data is a 1
        otherwise unaffected.

\end{itemize}

The value in bits 10, 9 and 8 can be anything from 0 through 7. This
    is \opcode{OR}'d with the current value in the interrupt level bits of the SR and
    the new value becomes the new interrupt level mask.

Once again, all unused bits must be zero in the data to prevent
    unpredictable results on different processors. (it is called defensive
    programming.)

This instruction can be used to turn off all interrupts except level
    7. These are known as non-{}maskable interrupts as they cannot be turned
    off.

\begin{lstlisting}[firstnumber=1,]
          TRAP #0
          ORI #$0700,SR
\end{lstlisting}

This sets the QL so that only a level 7 interrupt will be actioned.
    The only problem here is that CTRL ALT and 7 activate a level 7 interrupt
    and effectively hangs your QL. After the above instructions, the
    supervisor mode is still in effect. (Work it out in binary!!) To exit
    from supervisor mode \lstinline{ANDI \#\$07FF,SR} would need to be done -{} this leads us
    nicely into the AND family.

\section{This AND That}\mc6800x{AND}
\label{ch4-and}%\hyperlabel{ch4-and}%

In a similar manner to the \opcode{OR} instruction, the \opcode{AND} instruction needs
    two operands to work on to get a result.

The format of the \opcode{AND} instruction is:

\begin{lstlisting}[firstnumber=1,]
          AND.size source,Dn
\end{lstlisting}

or

\begin{lstlisting}[firstnumber=1,]
          AND.size Dn,destination
\end{lstlisting}

Note that as with the OR instruction, this form of the instruction
    requires either the source or the destination to be a data register. The
    size can be byte, word or long.

\opcode{AND} works according to the truth table for logical \opcode{AND} as per Table~\ref{tab:TruthTableForLogicalAND}.


\begin{table}[h]
\centering
\begin{tabular}{cc|c}

Source & Destination & AND\\ \hline
0 & 0 & 0 \\
0 & 1 & 0 \\
1 & 0 & 0 \\
1 & 1 & 1

\end{tabular}
\caption{Truth Table for Logical AND.}
\label{tab:TruthTableForLogicalAND}
\end{table}


Simply imagine each individual bit in the source is being \opcode{AND}ed with
    the same bit in the destination. The result -{} which will be stored in the
    destination bit -{} will always be a 1 if and only if both bits being
    processed are 1. If either are zero then the result will also be
    zero.

Using the same example as for OR above:

D0.W contains \$AAAA and D1.W contains \$6543 the instruction:

\begin{lstlisting}[firstnumber=1,]
          AND.W D0,D1
\end{lstlisting}

Will result in D1.W being set to \$2002 and D0 will remain unchanged.
    How does this work? Once again, in binary:

\begin{lstlisting}[firstnumber=1,frame=none,numbers=none]
D0 = $AAAA = 1010 1010 1010 1010
D1 = $6543 = 0110 0101 0100 0011
\end{lstlisting}

So using the truth table above, the result will be:

\begin{lstlisting}[firstnumber=1,frame=none,numbers=none]
D1 = $2002 = 0010 0000 0000 0010
\end{lstlisting}

The flags affected by AND are exactly the same as for \opcode{NOT}
    above.

The \opcode{ANDI}\mc6800x{ANDI} (immediate) instruction has the same variations as the \opcode{ORI} instruction as described above. These being:

\begin{lstlisting}[firstnumber=1,]
          ANDI.size #data,destination
\end{lstlisting}

And can be byte, word or long sized. It is used when the source
    value in the \opcode{AND} is immediate data as opposed to a register or memory
    address. Some, but not all, assemblers will allow you to write:

\begin{lstlisting}[firstnumber=1,]
          AND.size #data,destination
\end{lstlisting}

But the actual instruction assembled will be \opcode{ANDI} instead. Again the
    flags are affected as for \opcode{NOT}.

\begin{lstlisting}[firstnumber=1,]
          ANDI #data,CCR 
\end{lstlisting}

The size of this instruction is always byte, however, only the lower 5 bits are used. The 
   three high bits should, for safety, be set to 1 to avoid corrupying bits 5-7 of the CCR 
   which may be used for "other things" in different processors to the MC68008.

This is an instruction that can be used to clear some or all of
    the Condition Code flags. The flags are reset as follows:
\begin{itemize}[itemsep=0pt]

\item{}C is cleared if value in bit 0 of the data is a 0. Unchanged otherwise.


\item{}V is cleared if value in bit 1 of the data is a 0. Unchanged otherwise.


\item{}Z is cleared if value in bit 2 of the data is a 0. Unchanged otherwise.


\item{}N is cleared if value in bit 3 of the data is a 0. Unchanged otherwise.


\item{}X is cleared if value in bit 4 of the data is a 0. Unchanged otherwise.

\end{itemize}

\begin{lstlisting}[firstnumber=1,]
          ANDI #data,SR
\end{lstlisting}

This is another instruction which works on the status register but
    affects the entire width of the status register, not just the CCR
    byte.

As above, the flags are reset according to the value in bits 1 -{} 4
    of the immediate data. The rest of the status register is reset as follows
   :
\begin{itemize}[itemsep=0pt]

\item{}T (trace) is cleared if the value in bit 15 of the data is
        0. Unchanged otherwise.


\item{}S (supervisor) is cleared if the value in bit 13 of the data is
        0. Unchanged otherwise.

\end{itemize}

The value in bits 10, 9 and 8 is \opcode{AND}ed with the current value in the
    interrupt level bits of the SR and the new value becomes the new interrupt
    level mask.

All unused bits should be one in the data to prevent unpredictable
    results on different processors. These will be bits 14, 12, 11, 7, 6 and 5.

This instruction can be used to exit from supervisor mode. The
    instructions:

\begin{lstlisting}[firstnumber=1,]
          TRAP #0
          ANDI #$D7FF,SR
\end{lstlisting}

Would set the QL so that supervisor mode was first switched on (by
    the (\lstinline{TRAP #0}) and then only the supervisor bit in the SR was cleared (bit
    13) so the QL would revert to user mode. All other modes and interrupt
    levels and flags would remain unchanged.

\section{Exclusive OR Instructions}\mc6800x{EOR}
\label{ch4-eor}%\hyperlabel{ch4-eor}%

Having dealt with the \emph{inclusive or} instructions above, it is now
    time for the \emph{exclusive or} instructions. This has the format:

\begin{lstlisting}[firstnumber=1,]
          EOR.size Dn,destination
\end{lstlisting}

Where size can be byte, word or long. 

This instruction also sets the flags as per the NOT instruction. In
    the truth table for inclusive or, there was a 1 bit set in the result when
    there was a 1 in either the source or destination or both. Exclusive or is
    different and only allows a 1 in the result when there is a single 1 in
    either the source or destination. As shown in the truth table for Logical \opcode{EOR} in table~\ref{tab:TruthTableForLogicalEOR}.

\begin{table}[h]
\centering
\begin{tabular}{cc|c}

Source & Destination & EOR\\ \hline
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0

\end{tabular}
\caption{Truth Table for Logical EOR.}
\label{tab:TruthTableForLogicalEOR}
\end{table}

Using the same example as \opcode{OR} and \opcode{AND} above we now have the following
   :

D0.W contains \$AAAA and D1.W contains \$6543 the instruction

\begin{lstlisting}[firstnumber=1,]
          EOR.W D0,D1
\end{lstlisting}

Will result in D1.W being set to \$CFE9 and D0 will remain unchanged.
    How does this work? Once again, in binary:

\begin{lstlisting}[firstnumber=1,frame=none,numbers=none]
D0 = $AAAA = 1010 1010 1010 1010
D1 = $6543 = 0110 0101 0100 0011
\end{lstlisting}

So using the truth table above, the result will be:

\begin{lstlisting}[firstnumber=1,frame=none,numbers=none]
D1 = $CFE9 = 1100 1111 1110 1001
\end{lstlisting}

One feature of \opcode{EOR} is that if you \opcode{EOR} the result of a previous \opcode{EOR} with the same value again, you get back to the original value. Using this
    code:

\begin{lstlisting}[firstnumber=1,]
          MOVEQ #$AAAA,D0
          MOVEQ #$6543,D1
          EOR.W D0,D1
          EOR.W D0,D1
\end{lstlisting}

Will return us to the state we were in before the first \opcode{EOR}, in that
    D1 will once again hold the value \$6543. Try to work it out for yourselves
    using the example above as a guideline.

This can be used in a sort of `Pretty Bad Privacy' program where\program{Pretty Bad Privacy}
    data is encrypted using \opcode{EOR}. The following small program demonstrates
    this.

\begin{lstlisting}[firstnumber=1,caption={Pretty Bad Privacy Example},label={lst:PrettyBadPrivacy}]
START      MOVEQ     #7,D0
           LEA       DATA_STUFF,A1 
           MOVEQ     #100-1,D1
LOOP       EOR.B     D0,(A1)+
           DBF.S     D1,LOOP
           RTS

DATA_STUFF           Put 100 bytes of data here!
\end{lstlisting}

The \opcode{LEA} instruction is a new one and will be discussed soon. Suffice
    to say that it simply loads the address of the label `data\_stuff' into the
    address register named. This must be used in QL programs as they have to
    be able to run at any memory address. The \opcode{LEA} instruction allows
    this.

The above code is very simple and assumes that there is exactly 100
    bytes of data stored in memory at the location labeled `data\_stuff' To
    encrypt the data, simply call the routine at label `start' and 100 bytes
    will be encrypted. To decrypt it, simply call `start' again and the data
    will be restored. 

\begin{warning}This extremely bad for of encryption is extremely easily cracked because of the use of a single
    byte to encrypt the data so don't go using it for anything you value, such as your bank account details!
\end{warning}

\opcode{EORI} has the usual variations:\mc6800x{EORI}

\begin{lstlisting}[firstnumber=1,]
          EORI #data,destination
\end{lstlisting}


\begin{lstlisting}[firstnumber=1,]
          EORI #data,CCR
\end{lstlisting}

\lstinline{EORI \#data,CCR} is an instruction that is used to change some or all
    of the flags in the user byte of the status register. The flags are
    changed as follows:
\begin{itemize}[itemsep=0pt]

\item{}C is changed if the value in bit 0 of the data is a 1.


\item{}V is changed if the value in bit 1 of the data is a 1.


\item{}Z is changed if the value in bit 2 of the data is a 1.


\item{}N is changed if the value in bit 3 of the data is a 1.


\item{}X is changed if the value in bit 4 of the data is a 1.

\end{itemize}

\begin{lstlisting}[firstnumber=1,]
          EORI #data,SR
\end{lstlisting}

\lstinline{EORI \#data,SR} works upon the entire status register.

As above, the flags are changed according to the data -{} bits 0 to 4.
    The rest of the status register is changed as follows:
\begin{itemize}[itemsep=0pt]

\item{}T (trace) is changed if the value in bit 15 of the data is
        0.


\item{}S (supervisor) is changed if the value in bit 13 of the data is
        0.

\end{itemize}

The value in bits 10, 9 and 8 is \opcode{EOR}'d with the current value in the
    interrupt level bits of the SR and the new value becomes the new interrupt
    level mask.

\section{Shifting And Rotating}\mc6800x{LSL}\mc6800x{LSR}
\label{ch4-shift-rotate}%\hyperlabel{ch4-shift-rotate}%

There are 4 shift and 4 rotate instructions, 2 going left and 2
    going right.

\opcode{ASL} and \opcode{ASR} are arithmetic shifts while \opcode{LSL} and \opcode{LSR} are logical shifts. What is the difference? Taking the logical shifts first we have
   :

\begin{lstlisting}[firstnumber=1,]
          LSL.size Dx,Dy
\end{lstlisting}

or

\begin{lstlisting}[firstnumber=1,]
          LSL.size #data,Dy
\end{lstlisting}

or

\begin{lstlisting}[firstnumber=1,]
          LSL.W address
\end{lstlisting}

\opcode{LSR} has the same format, it just shifts in the opposite direction.
 

For the first two variations above, the data in Dy is affected and
    the size can be byte, word or long. The number of shifts that take place
    is defined by the value in register Dx Mod 64 or in the immediate data 
    where it can only be 1 to 8.

For the final variation, the size must be word only, and the data in
    that address and the address above it, is affected. For this format, there
    can only be a single shift at a time.
    

What happens is that the data is shifted by a single bit at a time.
    The bit that is shifted `out' of the register is placed into the C and X
    flags, while the `vacant' bit is filled with a zero.

Consider this example:

\begin{lstlisting}[firstnumber=1,caption={LSL Example},label={lst:LslExample}]
          MOVEQ    #$81,D0     ; D0.B is 1000 0001
          LSL.B    #1,D0       ; Now it is 0000 0010 and 
                               ; C and X are 1
          MOVEQ    #5,D2
          LSL.B    D2,D0       ; Now D0.B is 0100 0000
\end{lstlisting}

Shifting the opposite way gives this:

\begin{lstlisting}[firstnumber=1,caption={LSR Example},label={lst:LsrExample}]
          MOVEQ    #$81,D0     ; D0.B is 1000 0001
          LSR.B    #1,D0       ; Now it is 0100 0010 and
                               ; C and X are 1
          MOVEQ    #5,D2
          LSR.B    D2,D0       ; Now D0.B is 0000 0010
\end{lstlisting}

\opcode{LSL} is a quick way of multiplying an unsigned number by 2 for each
    bit shifted.

\opcode{LSR} is a quick way of dividing an unsigned number by 2 -{} but the
    fractions are lost. Another couple of examples:

\begin{lstlisting}[firstnumber=1,caption={LSL Multlication Example},label={lst:LsMultiplicationlExample}]
          MOVEQ    #8,D0       ; D0.L holds 8
          LSL.L    #1,D0       ; D0.L now holds 16
          LSL.L    #2,D0       ; D0.L now holds 64
\end{lstlisting}

\begin{lstlisting}[firstnumber=1,caption={LSR Division Example},label={lst:LsrDivisionExample}]
          MOVEQ    #10,D0      ; D0.L holds 10
          LSR.L    #1,D0       ; D0.L now holds 5
          LSR.L    #1,D0       ; D0.L now holds 2 but
                               ; note the remainder is `lost'
\end{lstlisting}

When specifying the number of shifts as immediate data, only values
    from 1 to 8 can be used. If the number of shifts required is greater than
    this, then a register counter has to be used. When shifting memory, the
    shift is always a single bit.

After a shift in either direction the flags are set as follows:

\begin{itemize}[itemsep=0pt]

\item{}N is set if the result became negative (MSB set to 1), cleared
        otherwise.


\item{}Z is set if the result became zero, cleared otherwise.


\item{}V is always cleared for \opcode{LSx}. For \opcode{ASx} V is set 
        if the most significant bit \emph{changed at any time} during the shift,
        or is cleared otherwise. (The MSB cannot actually change for an \opcode{ASR} 
        instruction!)


\item{}C is set to the LAST bit shifted out, \emph{cleared} if the shift count
        was zero.


\item{}X is set to the LAST bit shifted out. \emph{unaffected} if the shift
        count was zero.

\end{itemize}
\mc6800x{ASL}\mc6800x{ASR}
The arithmetic shifts -{} \opcode{ASL} and \opcode{ASR} -{} preserve the sign of the 
    value by duplicating the previous value of the sign bit in the new sign bit, so
    everything shifts as above, but the most significant bit of the byte, word
    or long being shifted, is shifted back into itself.

\section{Coming Up...}
\label{ch4-the-end}%\hyperlabel{ch4-the-end}%

In the next chapter we shall finish looking at the remainder of the
    instruction set for the MC6800x. That should conclude the most boring
    bits of learning about the processor.
